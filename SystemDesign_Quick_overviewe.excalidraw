{
  "type": "excalidraw",
  "version": 2,
  "source": "https://excalidraw.com",
  "elements": [
    {
      "id": "T7Fb7eG3WwcrHTiPQrPJf",
      "type": "text",
      "x": 216.890625,
      "y": 2906.14453125,
      "width": 1412.05908203125,
      "height": 2775,
      "angle": 0,
      "strokeColor": "#1e1e1e",
      "backgroundColor": "transparent",
      "fillStyle": "solid",
      "strokeWidth": 2,
      "strokeStyle": "solid",
      "roughness": 1,
      "opacity": 100,
      "groupIds": [],
      "frameId": null,
      "index": "a0",
      "roundness": null,
      "seed": 111694171,
      "version": 5164,
      "versionNonce": 2115644820,
      "isDeleted": false,
      "boundElements": [],
      "updated": 1740051319647,
      "link": null,
      "locked": false,
      "text": "* Functional Requirements. --  Behavioural Aspect of the system\n\n* Non functional Requirements. --  Availability, Consistency or partition tolerance of the system\nand good to have features\n\n* If DB is there, then do capacity estimations \n\n* Choice of DB:\n-> Relational DB\n    -> write heavy - VoltDB (In memory processing and also scales horizontally) \n                                - ACID properties are maintained and is distributed \n                                - In each partition, the transactions are executed serially which \n                                   ensures race conditions dont occur\n                                - 2phase commit (distributed transaction protocol) where all transactions agree on the outcome of the transaction\n                        - Operates on SINGLE LEADER replication\n\n    -> read heavy - MySQL, PostGreSQL \n                        - ACID properties and faster querying with sharding and indexing\n                        \n \n-> No SQL\n      - Cassandra\n                            - has shard and sort key(Wide column db)\n                            - uses LSM Trees + SS Tables (Can also add bloom filters before checking in SS Tables)\n                            - Multi-leader or leaderless (No single point of failure) \n                                    - Leaderless -quorum (where every node accepts a replica or read and write)\n                                                    - r+w>n (n - # of servers) - highly consistent\n                                                    - r+w<=n - eventually consistent. \n                                                        Read and write consensus should be discussed upon\n                            - For write conflicts, last write wins - No support for crdt's\n           \n                        \n                            \n\n             - RIAK \n                     - has shard and sort key (Wide column db)\n                     - Multi leader replication - for write conflicts, can used custom CRDT's\n                     - Support for leaderless as well\n                     - LSM Trees + SS Tables for faster reads\n             - Hbase: \n                    -> Columnar storage (best for analytics purpose)\n                    -> Columns compression + data locality for a column\n                    -> LSM Trees + Columnar stores. (Save data to lsm trees and when flushing, save to columnar part files)\n\n            - MongoDB:\n                     - Document store, can support varying schemas\n                      - sharding and indexing available\n                      - Transaction support available\n\n        -> Graph DB (neo4j and bfs/dfs for reading/writing)\n            - native / non-native ( 🔴 Check)\n\n\n                      \n* Caching\n\n\n    -> Distributed Caching - Redis/Mem cached - USES CONSISTENT HASHING [ CH : only certain keys are rearranged when a node is up/down] \n        ➡️ Redis : master slave, supports various dbs, pub-sup messaging pattern - DATA PERSISTENCE \n        ➡️ Memcached - simple Cache with no data persistence and no complex ds.    \n    \n     \n    -> Invalidation : done using TTL\n        Evictions: LRU, LFU, Time based expiration (Can use Hot-cold eviction strategy in general)\n        Patterns: \n                1️⃣ Cache-Aside (Lazy Loading)\n                ✔ App fetches data from cache first; if cache miss, fetch from DB and store in cache.\n                ✔ Best for: Read-heavy workloads (e.g., user profiles, product catalogs).\n                \n                2️⃣ Write-Through\n                ✔ Every write updates both cache & DB synchronously → Ensures consistency.\n                ✔ Best for: Data that is read frequently & must stay fresh (e.g., user sessions).\n                \n                3️⃣ Write-Behind (Write-Back) -  \n                ✔ Write goes only to cache, then asynchronously updates the DB.\n                ✔ Best for: High write-throughput systems (e.g., logging, analytics).\n                \n                4️⃣ Read-Through\n                ✔ App always reads from cache; cache fetches from DB on cache miss.\n                ✔ Best for: Abstracting cache logic from application (e.g., CDN-backed data).  \n\n* Queuing : Kafka (Distributed - consumer, producer, queues) \n                    -##- (In-memory MQ: rabbit mq , kafka - log based where consumers pull the messages)\n* Streaming / Batch processing :\n    Streaming: Spark Streaming - micro batch processing (can be tunable- to do event processing)\n                  Apache Flink - event processing\n             \n    Batch Processing: \n                    Spark Jobs/ MR jobs as needed\n* API's: \n    -> Unless it is not rest api, talk about these:\n        -> Long polling : client opens connection, waits for req/timeout before opening a new one \n            ➕ Best for periodic updates like notifications\n        -> Server Sent Events : one way communication, server sends events to client ( pub-sub way)\n            ➕ Best for freq notifications/ streaming updates\n        -> Web sockets - web handshake to establish connection, once established 2 way communication between client and server\n            ➕ Live chats/ gaming\n      -> Dataserialization -> Avro/protobuf/json/xml \n                               \n\n      -##-> Internal communication of servers -> (grpc - only on http 2.0) (protobufs ) \n\n*API Communication protocol - tcp vs udp [udp - live streaming and p2p protocol, no auth,  \n## webrtc - Auth + UDP,  ## RTMP - TCP based live streaming protocol, ##DASH - streaming protocol] \n\n\n\n\n-> CMS \n\n            ",
      "fontSize": 20,
      "fontFamily": 5,
      "textAlign": "left",
      "verticalAlign": "top",
      "containerId": null,
      "originalText": "* Functional Requirements. --  Behavioural Aspect of the system\n\n* Non functional Requirements. --  Availability, Consistency or partition tolerance of the system\nand good to have features\n\n* If DB is there, then do capacity estimations \n\n* Choice of DB:\n-> Relational DB\n    -> write heavy - VoltDB (In memory processing and also scales horizontally) \n                                - ACID properties are maintained and is distributed \n                                - In each partition, the transactions are executed serially which \n                                   ensures race conditions dont occur\n                                - 2phase commit (distributed transaction protocol) where all transactions agree on the outcome of the transaction\n                        - Operates on SINGLE LEADER replication\n\n    -> read heavy - MySQL, PostGreSQL \n                        - ACID properties and faster querying with sharding and indexing\n                        \n \n-> No SQL\n      - Cassandra\n                            - has shard and sort key(Wide column db)\n                            - uses LSM Trees + SS Tables (Can also add bloom filters before checking in SS Tables)\n                            - Multi-leader or leaderless (No single point of failure) \n                                    - Leaderless -quorum (where every node accepts a replica or read and write)\n                                                    - r+w>n (n - # of servers) - highly consistent\n                                                    - r+w<=n - eventually consistent. \n                                                        Read and write consensus should be discussed upon\n                            - For write conflicts, last write wins - No support for crdt's\n           \n                        \n                            \n\n             - RIAK \n                     - has shard and sort key (Wide column db)\n                     - Multi leader replication - for write conflicts, can used custom CRDT's\n                     - Support for leaderless as well\n                     - LSM Trees + SS Tables for faster reads\n             - Hbase: \n                    -> Columnar storage (best for analytics purpose)\n                    -> Columns compression + data locality for a column\n                    -> LSM Trees + Columnar stores. (Save data to lsm trees and when flushing, save to columnar part files)\n\n            - MongoDB:\n                     - Document store, can support varying schemas\n                      - sharding and indexing available\n                      - Transaction support available\n\n        -> Graph DB (neo4j and bfs/dfs for reading/writing)\n            - native / non-native ( 🔴 Check)\n\n\n                      \n* Caching\n\n\n    -> Distributed Caching - Redis/Mem cached - USES CONSISTENT HASHING [ CH : only certain keys are rearranged when a node is up/down] \n        ➡️ Redis : master slave, supports various dbs, pub-sup messaging pattern - DATA PERSISTENCE \n        ➡️ Memcached - simple Cache with no data persistence and no complex ds.    \n    \n     \n    -> Invalidation : done using TTL\n        Evictions: LRU, LFU, Time based expiration (Can use Hot-cold eviction strategy in general)\n        Patterns: \n                1️⃣ Cache-Aside (Lazy Loading)\n                ✔ App fetches data from cache first; if cache miss, fetch from DB and store in cache.\n                ✔ Best for: Read-heavy workloads (e.g., user profiles, product catalogs).\n                \n                2️⃣ Write-Through\n                ✔ Every write updates both cache & DB synchronously → Ensures consistency.\n                ✔ Best for: Data that is read frequently & must stay fresh (e.g., user sessions).\n                \n                3️⃣ Write-Behind (Write-Back) -  \n                ✔ Write goes only to cache, then asynchronously updates the DB.\n                ✔ Best for: High write-throughput systems (e.g., logging, analytics).\n                \n                4️⃣ Read-Through\n                ✔ App always reads from cache; cache fetches from DB on cache miss.\n                ✔ Best for: Abstracting cache logic from application (e.g., CDN-backed data).  \n\n* Queuing : Kafka (Distributed - consumer, producer, queues) \n                    -##- (In-memory MQ: rabbit mq , kafka - log based where consumers pull the messages)\n* Streaming / Batch processing :\n    Streaming: Spark Streaming - micro batch processing (can be tunable- to do event processing)\n                  Apache Flink - event processing\n             \n    Batch Processing: \n                    Spark Jobs/ MR jobs as needed\n* API's: \n    -> Unless it is not rest api, talk about these:\n        -> Long polling : client opens connection, waits for req/timeout before opening a new one \n            ➕ Best for periodic updates like notifications\n        -> Server Sent Events : one way communication, server sends events to client ( pub-sub way)\n            ➕ Best for freq notifications/ streaming updates\n        -> Web sockets - web handshake to establish connection, once established 2 way communication between client and server\n            ➕ Live chats/ gaming\n      -> Dataserialization -> Avro/protobuf/json/xml \n                               \n\n      -##-> Internal communication of servers -> (grpc - only on http 2.0) (protobufs ) \n\n*API Communication protocol - tcp vs udp [udp - live streaming and p2p protocol, no auth,  \n## webrtc - Auth + UDP,  ## RTMP - TCP based live streaming protocol, ##DASH - streaming protocol] \n\n\n\n\n-> CMS \n\n            ",
      "autoResize": true,
      "lineHeight": 1.25
    }
  ],
  "appState": {
    "gridSize": 20,
    "gridStep": 5,
    "gridModeEnabled": false,
    "viewBackgroundColor": "#ffffff"
  },
  "files": {}
}